{% extends "base.html" %}

{% block title %}CryptexQ Secure Chat Room{% endblock %}

{% block extra_css %}
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
<style>
:root {
  --bg-main: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
  --bg-panel: rgba(255, 255, 255, 0.08);
  --bg-soft: rgba(255, 255, 255, 0.05);
  --accent: #00c6ff;
  --accent-soft: rgba(0, 198, 255, 0.15);
  --accent-glow: rgba(0, 198, 255, 0.1);
  --accent-purple: #6366F1;
  --text-main: #ffffff;
  --text-muted: rgba(255, 255, 255, 0.7);
  --success: #10b981;
  --danger: #ef4444;
  --border-soft: rgba(255, 255, 255, 0.1);
}

/* ========== MESSAGE INTEGRITY INDICATORS ========== */
.integrity-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 0.7rem;
    padding: 2px 8px;
    border-radius: 12px;
    font-weight: 500;
    margin-left: 8px;
    vertical-align: middle;
}

.integrity-verified {
    background: rgba(16, 185, 129, 0.1);
    color: #059669;
    border: 1px solid rgba(16, 185, 129, 0.3);
}

.integrity-unverified {
    background: rgba(251, 191, 36, 0.1);
    color: #D97706;
    border: 1px solid rgba(251, 191, 36, 0.3);
}

.integrity-failed {
    background: rgba(239, 68, 68, 0.1);
    color: #DC2626;
    border: 1px solid rgba(239, 68, 68, 0.3);
}

.integrity-icon {
    font-size: 0.8rem;
}

.integrity-verified {
    animation: integrityPulse 2s ease-in-out;
}

@keyframes integrityPulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    font-family: 'Montserrat', sans-serif;
}

body {
  background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
  color: #ffffff;
  min-height: 100vh;
  overflow-x: hidden;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

#sessionBanner {
    background: linear-gradient(90deg, #2a7f7fa7, #6bffff8c);
    color: white;
    text-align: center;
    padding: 6px;
    font-weight: 600;
    font-size: 0.9rem;
    transition: background 1.2s ease, opacity 0.8s ease;
    animation: fadeColor 1.2s ease;
}

#sessionBanner.active {
    animation: glowPulse 2s infinite alternate;
}

@keyframes glowPulse {
    0% { box-shadow: 0 0 8px rgba(59, 130, 246, 0.1); }
    50% { box-shadow: 0 0 15px rgba(59, 130, 246, 0.3); }
    100% { box-shadow: 0 0 8px rgba(59, 130, 246, 0.1); }
}

@keyframes fadeColor {
    from { filter: brightness(1.2); opacity: 0.8; }
    to { filter: brightness(1); opacity: 1; }
}

.status-indicator {
    display: flex;
    align-items: center;
}

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    margin-right: 8px;
}

.connected {
    background-color: var(--success);
    box-shadow: 0 0 10px var(--success);
}

.disconnected {
    background-color: var(--light);
}

.warning {
    background-color: var(--danger);
    box-shadow: 0 0 10px var(--danger);
}

.tab-container {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    border-bottom: 2px solid #E5E7EB;
}

.tab {
    padding: 12px 24px;
    cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: all 0.3s;
    font-weight: 600;
    color: #6B7280;
}

.tab.active {
    border-bottom-color: var(--accent);
    color: var(--accent);
}

.tab-content {
    display: none;
}

.tab-content.active {
    display: block;
}

/* ====== 3 COLUMN LAYOUT ====== */
.talkroom-layout {
  display: grid;
  grid-template-columns: 280px 1fr 280px;
  gap: 20px;
  margin-bottom: 20px;
}

.side-panel {
  background: var(--bg-panel);
  border: 1px solid var(--border-soft);
  border-radius: 12px;
  padding: 20px;
}

.side-panel h3 {
  font-size: 1rem;
  margin-bottom: 16px;
  color: var(--text-main);
}

.side-panel ul {
  list-style: none;
  font-size: 0.85rem;
}

.side-panel li {
  margin-bottom: 10px;
  display: flex;
  justify-content: space-between;
  color: var(--text-muted);
}

.side-panel li span {
  font-weight: 600;
  color: var(--accent);
}

.chat-center {
  min-height: 600px;
}

.chat-container {
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(10px);
}

.status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 20px;
    background: rgba(255, 255, 255, 0.05);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    font-size: 0.85rem;
}

.key-exchange {
    display: flex;
    justify-content: space-between;
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    flex-wrap: wrap;
    gap: 20px;
}

.key-box {
    flex: 1;
    min-width: 250px;
}

.key-box h3 {
    margin-bottom: 10px;
    color: #00c6ff;
    font-size: 0.9rem;
    font-weight: 600;
}

.key-value {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 12px;
    font-family: 'SF Mono', Monaco, 'Courier New', monospace;
    font-size: 0.8rem;
    overflow-x: auto;
    white-space: normal;
    word-break: break-all;
    color: rgba(255, 255, 255, 0.8);
    min-height: 44px;
    position: relative;
}

.copy-btn {
    position: absolute;
    right: 8px;
    top: 8px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 4px;
    color: rgba(255, 255, 255, 0.7);
    padding: 4px 8px;
    font-size: 0.7rem;
    cursor: pointer;
    transition: background 0.2s;
}

.copy-btn:hover { 
    background: rgba(0, 198, 255, 0.2); 
    color: #00c6ff; 
}

button {
    background: linear-gradient(45deg, #00c6ff, #0072ff);
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.9rem;
    transition: transform 0.2s, box-shadow 0.2s;
    margin-top: 10px;
    width: 100%;
}

button:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 198, 255, 0.4);
}

button:disabled {
    background: rgba(255, 255, 255, 0.2);
    cursor: not-allowed;
}

.mode-settings {
    padding: 20px;
    background: rgba(255, 255, 255, 0.05);
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 0 0 12px 12px;
}

.mode-settings > div {
    padding: 15px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    margin-bottom: 15px;
    background: rgba(255, 255, 255, 0.03);
}

.chat-area {
    display: flex;
    flex-direction: column;
    height: 500px;
}

.chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.message {
    padding: 12px 16px;
    border-radius: 12px;
    max-width: 70%;
    word-wrap: break-word;
    animation: slideIn 0.3s;
}

@keyframes slideIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.message.sent {
    align-self: flex-end;
    background: var(--accent);
    color: white;
}

.message.received {
    align-self: flex-start;
    background: rgba(255, 255, 255, 0.1);
    color: #ffffff;
}

.message-info {
    font-size: 0.7rem;
    margin-top: 4px;
    opacity: 0.8;
}

.input-area {
    display: flex;
    gap: 10px;
    padding: 15px 20px;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    background: rgba(255, 255, 255, 0.05);
}

.input-area input {
    flex: 1;
    padding: 12px 16px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    font-size: 0.9rem;
    font-family: 'Montserrat', sans-serif;
    background: rgba(255, 255, 255, 0.05);
    color: #ffffff;
}

.input-area input:focus {
    outline: none;
    border-color: var(--accent);
}

.input-area button {
    margin-top: 0;
    width: auto;
    padding: 12px 24px;
}

.explanation {
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    padding: 30px;
    margin-bottom: 20px;
}

.explanation h3 {
    margin-bottom: 15px;
    color: var(--accent);
}

.explanation ol {
    margin-left: 20px;
}

.explanation li {
    margin-bottom: 12px;
    line-height: 1.6;
}

.footer {
    text-align: center;
    padding: 20px;
    color: var(--text-muted);
    font-size: 0.85rem;
}

.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.modal-content {
    background: rgba(15, 32, 39, 0.98);
    backdrop-filter: blur(20px);
    padding: 30px;
    border-radius: 12px;
    max-width: 500px;
    width: 90%;
    border: 1px solid rgba(255, 255, 255, 0.1);
}

.modal-content h2 {
    margin-bottom: 20px;
    color: var(--accent);
}

.modal-content input {
    width: 100%;
    padding: 12px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    margin-bottom: 20px;
    font-family: 'SF Mono', Monaco, 'Courier New', monospace;
    font-size: 0.8rem;
    background: rgba(255, 255, 255, 0.05);
    color: #ffffff;
}

.modal-buttons {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
}

.modal-buttons button.secondary {
    background: rgba(255, 255, 255, 0.1);
}

#modeIndicator {
    position: fixed;
    bottom: 20px;
    right: 25px;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 12px;
    padding: 10px 18px;
    color: #00c6ff;
    font-size: 0.9rem;
    font-weight: 600;
    box-shadow: 0 4px 6px rgba(0, 198, 255, 0.2);
    transition: all 0.3s ease;
    z-index: 99;
}

#modeIndicator.active-qkd {
    background: linear-gradient(45deg, #00c6ff, #0072ff);
    color: #FFFFFF;
    box-shadow: 0 4px 12px rgba(0, 198, 255, 0.4);
}

#modeIndicator.active-hybrid {
    background: linear-gradient(45deg, #6366F1, #8B5CF6);
    color: #FFFFFF;
    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
}

#modeIndicator:hover {
    transform: scale(1.05);
}

@media (max-width: 900px) {
    .talkroom-layout {
        grid-template-columns: 1fr;
    }
    .side-panel {
        display: none;
    }
    .key-exchange {
        flex-direction: column;
    }
    .message {
        max-width: 90%;
    }
}
</style>
{% endblock %}

{% block content %}
<!-- Secure Session Banner -->
<div id="sessionBanner">
    üîí Secure Session Not Active
</div>

<div class="container">
    <div style="text-align:center; margin: 2rem 0 1rem;">
        <h1>CryptexQ Secure Chat Room</h1>
        <p style="color: var(--text-muted);">End-to-end encrypted messaging with quantum-inspired security</p>
    </div>
    
    <div class="tab-container">
        <div class="tab active" onclick="switchTab('chat')">Secure Chat</div>
        <div class="tab" onclick="switchTab('explanation')">How It Works</div>
        <div class="tab" onclick="switchTab('settings')">Settings</div>
    </div>
    
    <div class="tab-content active" id="chat-tab">
        <!-- ====== 3 COLUMN LAYOUT WRAPPER ====== -->
        <div class="talkroom-layout">
            <!-- ===== LEFT : LIVE METRICS ===== -->
            <aside class="side-panel metrics-panel">
                <h3>üìä Live Metrics</h3>
                <ul>
                    <li>Messages Sent <span id="mSent">0</span></li>
                    <li>Messages Received <span id="mRecv">0</span></li>
                    <li>Messages / min <span id="mSpeed">0</span></li>
                    <li>Encryption Mode <span id="mMode">QKD + AES</span></li>
                    <li>Session Uptime <span id="mUptime">00:00</span></li>
                    <li>Tamper Alerts <span id="mTamper">0</span></li>
                </ul>
                <div style="margin-top:14px;">
                    <canvas id="msgRateChart" width="260" height="120"
                            style="background:rgba(0,0,0,0.25);
                                   border-radius:8px;
                                   border:1px solid rgba(255,255,255,0.08);">
                    </canvas>
                </div>
            </aside>

            <!-- ===== CENTER : CHAT ===== -->
            <main class="chat-center">
                <div class="chat-container">
                    <!-- ===== STATUS BAR ===== -->
                    <div class="status-bar">
                        <div class="status-indicator">
                            <div class="status-dot disconnected" id="connection-dot"></div>
                            <span id="connection-status">Connection: Not Established</span>
                        </div>
                        <div>
                            <span id="session-status">Encryption: Not Established</span>
                        </div>
                    </div>

                    <!-- ===== KEY EXCHANGE ===== -->
                    <div class="key-exchange">
                        <div class="key-box">
                            <h3>Your Public Key</h3>
                            <div class="key-value" id="public-key">
                                Not generated yet
                                <button class="copy-btn" onclick="copyToClipboard('public-key')" style="display:none">
                                    <i class="fas fa-copy"></i> Copy
                                </button>
                            </div>
                            <button id="generate-btn">
                                <i class="fas fa-key"></i> Generate Keys & Register
                            </button>
                        </div>

                        <div class="key-box">
                            <h3>Friend's Public Key</h3>
                            <div class="key-value" id="friend-key">
                                Waiting for friend to connect...
                                <button class="copy-btn" onclick="copyToClipboard('friend-key')" style="display:none">
                                    <i class="fas fa-copy"></i> Copy
                                </button>
                            </div>
                            <button id="friend-btn" disabled>
                                <i class="fas fa-user-friends"></i> Enter Friend's Key
                            </button>
                        </div>

                        <div class="key-box">
                            <h3>Session Key</h3>
                            <div class="key-value" id="session-key">
                                Not established yet
                                <button class="copy-btn" onclick="copyToClipboard('session-key')" style="display:none">
                                    <i class="fas fa-copy"></i> Copy
                                </button>
                            </div>
                            <button id="session-btn" disabled>
                                <i class="fas fa-handshake"></i> Establish Session
                            </button>
                        </div>
                    </div>

                    <!-- ===== MODE SETTINGS ===== -->
                    <div class="mode-settings">
                        <div id="security-mode-box">
                            <label><i class="fas fa-shield-alt"></i> Encryption Mode:</label>
                            <select id="securityMode">
                                <option value="qkd">QKD + AES</option>
                                <option value="hybrid">Hybrid PQC + AES</option>
                            </select>
                            <button id="applyModeBtn">
                                <i class="fas fa-check"></i> Apply Mode
                            </button>
                            <div id="modeStatus">Switched to QKD + AES mode active. (re-establish to apply)</div>
                        </div>
                    </div>

                    <!-- ===== CHAT AREA ===== -->
                    <div class="chat-area">
                        <div class="chat-messages" id="chat-messages">
                            <div class="message received">
                                <div>Welcome to CryptexQ Secure Chat!</div>
                                <div class="message-info">System ‚Ä¢ Just now</div>
                            </div>
                        </div>

                        <div class="input-area">
                            <input type="text" id="message-input"
                                   placeholder="Type your message here..." disabled>
                            <button id="send-btn" disabled>
                                <i class="fas fa-paper-plane"></i> Send
                            </button>
                        </div>
                    </div>
                </div>
            </main>

            <!-- ===== RIGHT : SESSION INFO ===== -->
            <aside class="side-panel session-panel">
                <h3>üîê Session Info</h3>
                <ul>
                    <li>User <span id="sUser">‚Äî</span></li>
                    <li>Peer <span id="sPeer">‚Äî</span></li>
                    <li>Mode <span id="sMode">QKD + AES</span></li>
                    <li>Status <span id="sStatus">‚Äî</span></li>
                    <li>Integrity <span>HMAC-SHA256</span></li>
                </ul>
            </aside>
        </div>
    </div>
    
    <div class="tab-content" id="explanation-tab">
        <div class="explanation">
            <h3><i class="fas fa-info-circle"></i> How CryptexQ Secure Chat Works</h3>
            <p>This implementation demonstrates a production-ready secure messaging system with quantum-inspired encryption:</p>
            <ol>
                <li><strong>Key Generation</strong> ‚Äì Each user generates a public/private key pair in the browser. The public key is sent to the server and <b>shown in full</b> in "Your Public Key".</li>
                <li><strong>Key Exchange</strong> ‚Äì The server uses those public keys to perform either simulated QKD or post-quantum Kyber KEM, depending on the selected mode.</li>
                <li><strong>Session Establishment</strong> ‚Äì A shared secret is derived and turned into an AES-256 key using WebCrypto.</li>
                <li><strong>Message Encryption</strong> ‚Äì All chat messages are encrypted with AES-GCM in the browser before being sent.</li>
                <li><strong>Message Decryption</strong> ‚Äì The receiving browser decrypts using the same session key. The server never sees plaintext.</li>
            </ol>
        </div>
    </div>
    
    <div class="tab-content" id="settings-tab">
        <div class="explanation">
            <h3><i class="fas fa-cog"></i> Application Settings</h3>
            <div style="margin-top: 20px;">
                <label>
                    <input type="checkbox" id="auto-copy-key" checked>
                    Auto-copy generated keys to clipboard
                </label>
            </div>
            <div style="margin-top: 15px;">
                <label>
                    <input type="checkbox" id="show-encrypted" checked>
                    Show encrypted message content (in console)
                </label>
            </div>
            <div style="margin-top: 15px;">
                <label>
                    <input type="checkbox" id="auto-establish" checked>
                    Automatically establish session when both users are ready
                </label>
            </div>
            <div style="margin-top: 30px;">
                <button id="reset-btn"><i class="fas fa-undo"></i> Reset Application</button>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p>CryptexQ ‚Äî Quantum-Safe Messaging</p>
    </div>
</div>

<!-- Friend Key Modal -->
<div class="modal" id="friend-key-modal">
    <div class="modal-content">
        <h2>Enter Friend's Public Key</h2>
        <input type="text" id="friend-key-input" placeholder="Paste friend's public key here">
        <div class="modal-buttons">
            <button class="secondary" onclick="hideFriendKeyModal()">Cancel</button>
            <button onclick="saveFriendKey()">Save Key</button>
        </div>
    </div>
</div>

<!-- Floating Mode Label -->
<div id="modeIndicator">
    Mode: <span id="modeIndicatorText">QKD + AES</span> üîµ
</div>
{% endblock %}

{% block extra_js %}
<!-- Socket.IO client from CDN -->
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js" crossorigin="anonymous"></script>

<!-- Message Integrity Helper -->
<script src="{{ url_for('static', filename='js/message_integrity_helper.js') }}"></script>

<script>
// Initialize Message Integrity Helper
const messageIntegrity = new MessageIntegrityHelper();

// -------- Tabs --------
function byId(id) {
    return document.getElementById(id);
}

let hmacKey = null;

function switchTab(tabId) {
    document.querySelectorAll(".tab-content").forEach(div => div.classList.remove("active"));
    document.querySelectorAll(".tab").forEach(tab => tab.classList.remove("active"));
    document.getElementById(tabId + "-tab").classList.add("active");
    document.querySelector(`.tab[onclick="switchTab('${tabId}')"]`).classList.add("active");
}

// -------- Socket & state --------
const socket = io();
let username = null;
let peer = null;
let aesKey = null;
let mode = "qkd"; // default
let myPubB64 = null;

// DOM refs
const connectionDot = document.getElementById("connection-dot");
const connectionStatus = document.getElementById("connection-status");
const sessionStatus = document.getElementById("session-status");
const sessionBanner = document.getElementById("sessionBanner");

const publicKeyBox = document.getElementById("public-key");
const friendKeyBox = document.getElementById("friend-key");
const sessionKeyBox = document.getElementById("session-key");

const generateBtn = document.getElementById("generate-btn");
const friendBtn = document.getElementById("friend-btn");
const sessionBtn = document.getElementById("session-btn");
const sendBtn = document.getElementById("send-btn");
const messageInput = document.getElementById("message-input");
const chatBox = document.getElementById("chat-messages");
const securityModeSelect = byId("securityMode");
const modeSelect = byId("modeSelect");

// -------- Utils --------
function updateStatus(text, colorClass = "connected") {
    connectionDot.className = "status-dot " + colorClass;
    connectionStatus.textContent = "Connection: " + text;
}

function updateBanner(active, text) {
    if (active) {
        sessionBanner.style.background =
            mode === "qkd"
                ? "linear-gradient(90deg, #00b4d8, #4361ee)"
                : "linear-gradient(90deg, #b5179e, #7209b7)";
        sessionBanner.textContent = "üîê " + text;
        sessionBanner.classList.add("active");

        // Sound + flash effect
        playSound("connect");
        sessionBanner.animate(
            [
                { opacity: 0.5, transform: "scale(0.95)" },
                { opacity: 1, transform: "scale(1.05)" },
                { opacity: 1, transform: "scale(1)" },
            ],
            { duration: 1200, easing: "ease-out" }
        );
    } else {
        sessionBanner.style.background = "linear-gradient(90deg, #e63946, #ff6b6b)";
        sessionBanner.textContent = text || "üîí Secure Session Not Active";
        sessionBanner.classList.remove("active");
        playSound("disconnect");
    }
}

// ---- Floating Mode Indicator Logic ----
function updateModeIndicator() {
    const el = document.getElementById("modeIndicator");
    if (!el) return;

    if (mode === "qkd") {
        el.classList.remove("active-hybrid");
        el.classList.add("active-qkd");
        el.innerHTML = `Mode: <span id="modeIndicatorText">QKD + AES</span> üîµ`;
    } else {
        el.classList.remove("active-qkd");
        el.classList.add("active-hybrid");
        el.innerHTML = `Mode: <span id="modeIndicatorText">Hybrid PQC-Kyber + AES</span> üü£`;
    }

    el.animate(
        [
            { transform: "scale(1)", opacity: 1 },
            { transform: "scale(1.1)", opacity: 0.8 },
            { transform: "scale(1)", opacity: 1 },
        ],
        { duration: 600, easing: "ease-out" }
    );
}

function copyToClipboard(elementId) {
    const el = document.getElementById(elementId);
    const text = el.textContent.trim();
    if (!text) return;
    navigator.clipboard.writeText(text);
}

function handleKeyPress(e) {
    if (e.key === "Enter") {
        e.preventDefault();
        sendMessage();
    }
}

function resetApplication() {
    window.location.reload();
}

// -------- Socket events --------
socket.on("connect", () => updateStatus("Connected", "connected"));
socket.on("disconnect", () => updateStatus("Disconnected", "disconnected"));

async function ensureRegistered() {
    if (username && myPubB64) return;

    // Try reading from localStorage
    username = sessionStorage.getItem("cryptexq_username");

    if (!username) {
        // fallback for direct link access
        username = prompt("Enter your username to continue:");
        if (!username) return;
        localStorage.setItem("cryptexq_username", username);
    }

    // proceed with ECDH keygen
    await new Promise(r => requestAnimationFrame(r)); // ensures gesture unlock

    const kp = await crypto.subtle.generateKey(
        { name: "ECDH", namedCurve: "P-256" },
        true,
        ["deriveKey", "deriveBits"]
    );
    window.ecdhKeyPair = kp;

    const pubRaw = await crypto.subtle.exportKey("raw", kp.publicKey);
    myPubB64 = btoa(String.fromCharCode(...new Uint8Array(pubRaw)));
    publicKeyBox.textContent = myPubB64;

    const copyBtn = document.querySelector("#public-key .copy-btn");
    if (copyBtn) copyBtn.style.display = "inline-block";

    socket.emit("register", { username, x25519_pub_b64: myPubB64 });
}

socket.on("registered", data => {
    sessionStatus.textContent = `‚úÖ Registered as ${data.username}`;
    updateStatus("Online", "connected");
});

// ------------------- ONLINE USERS HANDLING (AUTO SESSION) -------------------
socket.on("online_users", data => {
    console.log("[online_users]", data);
    const list = data.users.filter(u => u !== username);

    if (list.length > 0) {
        peer = list[0];
        friendKeyBox.textContent = "Connected to: " + peer;
        friendBtn.disabled = false;
        sessionBtn.disabled = false;

        // Automatically start session if user chose auto-establish
        const auto = document.getElementById("auto-establish");
        if (auto && auto.checked && !aesKey) {
            console.log("[auto] establishing session with", peer, "in mode", mode);
            sessionKeyBox.textContent = "Negotiating secure session via " +
                (mode === "qkd" ? "QKD" : "Hybrid Kyber") + "...";
            if (mode === "qkd") {
                socket.emit("start_qkd_session", { from: username, to: peer });
            } else {
                socket.emit("request_start_session", { from: username, to: peer });
            }
        }
    } else {
        friendKeyBox.textContent = "Waiting for friend to connect...";
        friendBtn.disabled = true;
        sessionBtn.disabled = true;
        peer = null;
    }
});

// -------- Mode handling --------
function syncModeUI() {
    if (securityModeSelect) {
        securityModeSelect.value = mode;
    }

    if (modeSelect) {
        modeSelect.value = mode;
    }

    const modeText = mode === "qkd" ? "QKD + AES" : "Hybrid PQC-Kyber + AES";

    const statusEl = document.getElementById("modeStatus");
    if (statusEl) statusEl.textContent = `Switched to ${modeText} mode active. (re-establish to apply)`;

    updateBanner(false, "üîí Secure Session Not Active");
    updateModeIndicator();
}

function applyMode() {
    mode = securityModeSelect.value;
    syncModeUI();
    updateModeIndicator();
    if (peer) startSession();
}

if (securityModeSelect) {
    securityModeSelect.addEventListener("change", () => {
        mode = securityModeSelect.value;
        syncModeUI();
    });
}

if (modeSelect) {
    modeSelect.addEventListener("change", () => {
        mode = modeSelect.value;
        syncModeUI();
    });
}

// -------- Friend key modal (optional manual demo) --------
function showFriendKeyModal() {
    document.getElementById("friend-key-modal").style.display = "flex";
}

function hideFriendKeyModal() {
    document.getElementById("friend-key-modal").style.display = "none";
}

function saveFriendKey() {
    const val = document.getElementById("friend-key-input").value.trim();
    if (val) {
        friendKeyBox.textContent = val;
        sessionBtn.disabled = false;
        hideFriendKeyModal();
    }
}

// Make these functions available to inline HTML
window.showFriendKeyModal = showFriendKeyModal;
window.hideFriendKeyModal = hideFriendKeyModal;
window.saveFriendKey = saveFriendKey;
window.copyToClipboard = copyToClipboard;
window.switchTab = switchTab;
window.handleKeyPress = handleKeyPress;

// -------- Key generation & session --------
async function generateKeys() {
    await ensureRegistered();
    friendBtn.disabled = false;
}

function startSession() {
    if (!peer) {
        alert("No peer available yet. Open talkroom on another device/tab and register there.");
        return;
    }
    sessionKeyBox.textContent = "Negotiating secure session via " + (mode === "qkd" ? "QKD" : "Hybrid Kyber") + "...";
    if (mode === "qkd") {
        socket.emit("start_qkd_session", { from: username, to: peer });
    } else {
        socket.emit("request_start_session", { from: username, to: peer });
    }
}

socket.on("qkd_shared_key", async data => {
    const raw = Uint8Array.from(atob(data.shared_b64), c => c.charCodeAt(0));
    aesKey = await crypto.subtle.importKey("raw", raw, { name:"AES-GCM" }, false, ["encrypt","decrypt"]);
    hmacKey = await crypto.subtle.importKey(
        "raw",
        raw,
        { name: "HMAC", hash: "SHA-256" },
        false,
        ["sign", "verify"]
    );

    sessionKeyBox.textContent = "üîê AES-256 Session Key (from QKD) ‚Äì value hidden";
    const copyBtn = document.querySelector("#session-key .copy-btn");
    if (copyBtn) copyBtn.style.display = "none";

    sendBtn.disabled = false;
    messageInput.disabled = false;
    updateBanner(true, "QKD-AES session active");
    sessionStatus.textContent = "üîê Session Active";
});

socket.on("kyber_shared_for_initiator", async data => {
    const raw = Uint8Array.from(atob(data.kyber_ss_b64), c => c.charCodeAt(0));
    aesKey = await crypto.subtle.importKey("raw", raw, { name:"AES-GCM" }, false, ["encrypt","decrypt"]);
    hmacKey = await crypto.subtle.importKey(
        "raw",
        raw,
        { name: "HMAC", hash: "SHA-256" },
        false,
        ["sign", "verify"]
    );

    sessionKeyBox.textContent = "üîê AES-256 Session Key (from Kyber PQC) ‚Äì value hidden";
    const copyBtn = document.querySelector("#session-key .copy-btn");
    if (copyBtn) copyBtn.style.display = "none";

    sendBtn.disabled = false;
    messageInput.disabled = false;
    updateBanner(true, "Hybrid PQC-Kyber session active");
    sessionStatus.textContent = "üîê Hybrid PQC-Kyber session active";
});

socket.on("kyber_ready_peer", async data => {
    const raw = Uint8Array.from(atob(data.kyber_ss_b64), c => c.charCodeAt(0));
    aesKey = await crypto.subtle.importKey("raw", raw, { name:"AES-GCM" }, false, ["encrypt","decrypt"]);
    hmacKey = await crypto.subtle.importKey(
        "raw",
        raw,
        { name: "HMAC", hash: "SHA-256" },
        false,
        ["sign", "verify"]
    );

    sessionKeyBox.textContent = "üîê AES-256 Session Key (from Kyber PQC) ‚Äì value hidden";
    const copyBtn = document.querySelector("#session-key .copy-btn");
    if (copyBtn) copyBtn.style.display = "none";

    sendBtn.disabled = false;
    messageInput.disabled = false;
    updateBanner(true, "Hybrid PQC-Kyber session active");
    sessionStatus.textContent = "üîê Hybrid PQC-Kyber session active";
});

// -------- Chat --------
async function sendMessage() {
    if (!aesKey) return alert("No active session key!");
    const msg = messageInput.value.trim();
    if (!msg) return;

    // for demo clarity
    console.log(`[mode] Encrypting using mode: ${mode}`);
    console.log(`[key source] Using ${mode === 'qkd' ? 'Quantum-derived key' : mode === 'pqc' ? 'Kyber512 public key exchange' : 'Hybrid key mix'}`);

    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ctBuf = await crypto.subtle.encrypt(
        { name:"AES-GCM", iv },
        aesKey,
        new TextEncoder().encode(msg)
    );
    const ctUint8 = new Uint8Array(ctBuf);
    const ctB64 = btoa(String.fromCharCode(...ctUint8));
    const ivB64 = btoa(String.fromCharCode(...iv));
    
    if (document.getElementById("show-encrypted").checked) {
        console.log("Ciphertext (b64):", ctB64);
        console.log("IV (b64):", ivB64);
    }

    // HMAC-SHA256 over plaintext
    const macBuf = await crypto.subtle.sign(
        "HMAC",
        hmacKey,
        new TextEncoder().encode(msg)
    );
    const macB64 = btoa(String.fromCharCode(...new Uint8Array(macBuf)));

    socket.emit("send_encrypted_message", {
        from: username,
        to: peer,
        ciphertext_b64: ctB64,
        iv_b64: ivB64,
        mac_b64: macB64
    });

    // Don't display immediately - wait for server echo with integrity data
    messageInput.value = "";
}

socket.on("new_encrypted_message", async data => {
    if (!aesKey || !hmacKey) {
        console.warn("Received encrypted message but no session keys yet");
        return;
    }

    // Decode ciphertext and IV
    const ct = Uint8Array.from(atob(data.ciphertext_b64), c => c.charCodeAt(0));
    const iv = Uint8Array.from(atob(data.iv_b64), c => c.charCodeAt(0));

    // Decrypt
    const ptBuf = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv },
        aesKey,
        ct
    );

    const msg = new TextDecoder().decode(ptBuf);

    // VERIFY HMAC (integrity + authentication)
    const valid = await crypto.subtle.verify(
        "HMAC",
        hmacKey,
        Uint8Array.from(atob(data.mac_b64), c => c.charCodeAt(0)),
        new TextEncoder().encode(msg)
    );

    if (!valid) {
        alert("‚ö†Ô∏è Message authentication failed! Possible tampering detected.");
        console.error("HMAC verification failed");
        return;
    }

    // Only display message if HMAC is valid
    // Display as "You" if sender is current user
    const displayName = (data.from === username) ? "You" : data.from;
    addMessage(displayName, msg, data.integrity);
});

function addMessage(sender, text, integrityData) {
    const div = document.createElement("div");
    div.className = "message " + (sender === "You" ? "sent" : "received");
    
    // Create integrity badge
    let integrityBadge = '';
    if (integrityData && integrityData.type === 'HMAC_SHA256') {
        integrityBadge = '<span class="integrity-badge integrity-verified" title="Message integrity verified by server"><span class="integrity-icon">üîí</span> Verified</span>';
    } else {
        integrityBadge = '<span class="integrity-badge integrity-unverified" title="Message from legacy client (no integrity signature)"><span class="integrity-icon">‚ö†Ô∏è</span> Unverified</span>';
    }
    
    div.innerHTML = `<strong>${sender}:</strong> ${text} ${integrityBadge}`;
    chatBox.appendChild(div);
    chatBox.scrollTop = chatBox.scrollHeight;
}

// -------- Init --------
window.addEventListener("DOMContentLoaded", () => {
    syncModeUI();
    generateBtn.onclick = generateKeys;
    friendBtn.onclick = showFriendKeyModal;
    sessionBtn.onclick = startSession;
    const startBtn = document.getElementById("start-btn");
    if (startBtn) startBtn.onclick = startSession;

    sendBtn.onclick = sendMessage;
    messageInput.addEventListener("keypress", handleKeyPress);
    document.getElementById("applyModeBtn").onclick = applyMode;
    document.getElementById("reset-btn").onclick = resetApplication;
});

// Optional: subtle sound cues for connection/mode change
function playSound(type) {
    try {
        const soundUrl =
            type === "connect"
                ? "https://assets.mixkit.co/sfx/preview/mixkit-software-interface-start-2574.mp3"
                : "https://assets.mixkit.co/sfx/preview/mixkit-system-beep-buzzer-fail-2964.mp3";

        const audio = new Audio(soundUrl);
        audio.play().catch(() => {
            // Autoplay blocked or unsupported ‚Äì ignore safely
        });
    } catch (e) {
        // Audio not supported ‚Äì ignore
    }
}
</script>

<script>
/* ===============================
   CryptexQ Live Metrics Engine
================================ */

let metrics = {
    sent: 0,
    received: 0,
    tamper: 0,
    startTime: null,
};

// DOM refs
const mSent   = document.getElementById("mSent");
const mRecv   = document.getElementById("mRecv");
const mSpeed  = document.getElementById("mSpeed");
const mMode   = document.getElementById("mMode");
const mUptime = document.getElementById("mUptime");
const mTamper = document.getElementById("mTamper");

// Session info panel
const sUser   = document.getElementById("sUser");
const sPeer   = document.getElementById("sPeer");
const sMode   = document.getElementById("sMode");
const sStatus = document.getElementById("sStatus");

/* ---------- Utilities ---------- */
function updateUptime() {
    if (!metrics.startTime) return;
    const diff = Math.floor((Date.now() - metrics.startTime) / 1000);
    const min = String(Math.floor(diff / 60)).padStart(2, "0");
    const sec = String(diff % 60).padStart(2, "0");
    mUptime.textContent = `${min}:${sec}`;
}

function updateSpeed() {
    if (!metrics.startTime) return;
    const mins = (Date.now() - metrics.startTime) / 60000;
    mSpeed.textContent = mins > 0 ? (metrics.sent / mins).toFixed(1) : "0";
}

/* ---------- Hook into EXISTING flow ---------- */

// When session becomes active
function onSessionEstablished() {
    metrics.startTime = Date.now();
    sStatus.textContent = "Active";
    setInterval(updateUptime, 1000);
    setInterval(updateSpeed, 3000);
}

// Message sent
function onMessageSent() {
    metrics.sent++;
    mSent.textContent = metrics.sent;
}

// Message received
function onMessageReceived() {
    metrics.received++;
    mRecv.textContent = metrics.received;
}

// Tamper detected
function onTamperDetected() {
    metrics.tamper++;
    mTamper.textContent = metrics.tamper;
}

// Mode sync
function syncMetricMode(mode) {
    const label = mode === "qkd" ? "QKD + AES" : "Hybrid PQC + AES";
    mMode.textContent = label;
    sMode.textContent = label;
}

/* ---------- SAFE PATCHING ---------- */

// Patch sendMessage()
const _sendMessage = sendMessage;
sendMessage = async function () {
    await _sendMessage();
    onMessageSent();
};

// Patch incoming messages
const _alert = window.alert;
window.alert = function (msg) {
    if (msg && msg.includes("authentication failed")) {
        onTamperDetected();
    }
    _alert(msg);
};

// Patch session start
socket.on("qkd_shared_key", () => onSessionEstablished());
socket.on("kyber_shared_for_initiator", () => onSessionEstablished());
socket.on("kyber_ready_peer", () => onSessionEstablished());

// Patch mode updates
const _applyMode = applyMode;
applyMode = function () {
    _applyMode();
    syncMetricMode(mode);
};

// Initial UI sync
document.addEventListener("DOMContentLoaded", () => {
    mSent.textContent = "0";
    mRecv.textContent = "0";
    mSpeed.textContent = "0";
    mTamper.textContent = "0";
    mUptime.textContent = "00:00";

    sUser.textContent = localStorage.getItem("cryptexq_username") || "‚Äî";
    sStatus.textContent = "Inactive";
    syncMetricMode(mode);
});
</script>

<script>
/* ===============================
   CryptexQ Message Rate Graph
================================ */

const canvas = document.getElementById("msgRateChart");
const ctx = canvas.getContext("2d");

let rateHistory = new Array(30).fill(0); // last ~90 seconds
let lastTotalMessages = 0;

function drawGraph() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Grid
    ctx.strokeStyle = "rgba(255,255,255,0.08)";
    ctx.lineWidth = 1;
    for (let y = 0; y <= 4; y++) {
        const py = (canvas.height / 4) * y;
        ctx.beginPath();
        ctx.moveTo(0, py);
        ctx.lineTo(canvas.width, py);
        ctx.stroke();
    }

    // Line
    ctx.beginPath();
    ctx.strokeStyle = "#00d1ff";
    ctx.lineWidth = 2;

    rateHistory.forEach((v, i) => {
        const x = (i / (rateHistory.length - 1)) * canvas.width;
        const y = canvas.height - (v / 10) * canvas.height;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });

    ctx.stroke();

    // Glow
    ctx.shadowColor = "#00d1ff";
    ctx.shadowBlur = 12;
    ctx.stroke();
    ctx.shadowBlur = 0;
}

function updateGraph() {
    const total = metrics.sent + metrics.received;
    const delta = total - lastTotalMessages;
    lastTotalMessages = total;

    rateHistory.push(delta);
    rateHistory.shift();

    drawGraph();
}

// Update every 3 seconds
setInterval(updateGraph, 3000);

// Initial draw
drawGraph();
</script>
{% endblock %}
